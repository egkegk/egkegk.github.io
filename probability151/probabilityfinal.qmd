---
title: "Graphical Analysis of Airport Connections"
output: html_document
date: "2023-05-01"
author: "Emrys King"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, results='hide', out.width = "80%", fig.keep='all', fig.align = "center")
## cite sources!
# https://stackoverflow.com/questions/16584948/how-to-create-weighted-adjacency-list-matrix-from-edge-list <- used to convert data table (edgelist) to an adjacency matrix
# https://kateto.net/netscix2016.html <- used to learn about igraph package
# https://cran.rstudio.com/web/packages/tnet/tnet.pdf <- tnet package info
# debugging <- https://www.statology.org/r-list-object-cannot-be-coerced-to-type-double/
# https://www.r-bloggers.com/2020/03/community-detection-with-louvain-and-infomap/ <- louvain method
# https://stackoverflow.com/questions/49834827/louvain-community-detection-in-r-using-igraph-format-of-edges-and-vertices <- louvain method

## necessary packages for this analysis
library(tnet)
library(igraph)
```


```{r include=FALSE}
par(mar=c(0,0,0,0))

## Loading data and creating graph (without communities)
net <- read.table("http://opsahl.co.uk/tnet/datasets/USairport500.txt", header=FALSE, col.names = c("v1", "v2", "w"))
g <- graph.data.frame(net)
adjmat <- get.adjacency(g,sparse=FALSE)

graphnet <- graph_from_adjacency_matrix(adjmat)
graphnet2 <- as.undirected(graphnet, mode="each")
graphlay <- layout_with_fr(graphnet2)
plot(graphnet2, layout=graphlay, vertex.size=5, size2=1, 
     vertex.label=NA)

## Louvain method
weight <- net$w
commnet <- cluster_louvain(graphnet2, weights=weight)

## creating less cluttered graphs
edges <- E(graphnet2)
simple1 <- !crossing(commnet, graphnet2)
simple2 <- crossing(commnet, graphnet2)
simnet1 <- edges[simple1]
simnet2 <- edges[simple2]

simgraph1 <- delete_edges(graphnet2, simnet1)
simgraph2 <- delete_edges(graphnet2, simnet2)
```

In this exploratory analysis, I was interested in utilizing community clustering algorithms on real-world data. Leveraging my knowledge of the Louvain community clustering algorithm, I familiarized myself with the `tnet` package. I then applied the clustering algorithm to a [dataset](http://opsahl.co.uk/tnet/datasets/USairport500.txt) representing connections between the [500 busiest airports in the United States](https://toreopsahl.com/datasets/#usairports). In the following visualizations, a node represents an airport, and an edge represents a flight connecting two airports. The edges are undirected, meaning that the departure/destination of the flight is unspecified in this dataset. No identifying information is given for the airports themselves.

This first graphical representation presents the dataset in its entirety with the Louvain algorithm's clusters depicted as background shading. Six clusters was calculated as the optimal number. Red edges denote inter-cluster edges, while black edges denote intra-cluster edges. Note that the green, red, light blue, and yellow clusters seem to overlap much more than the dark blue and pink clusters.

```{r}
## plotting the results
plot(commnet,
     graphnet2,
     layout=graphlay,
     mark.expand = 20,
     vertex.size=5, size2=1, 
     vertex.label=NA)
```

The following two graphs remove the intra- and inter-cluster edges, respectively, for ease of viewing. The first of these graphs removes many of the edges, allowing us to see only the red inter-cluster connections. The nodes connected to these edges likely represent large cities' airports or other airline hubs. The clusters with fewer nodes connecting to red edges may be interpreted as regional airport networks.

```{r}
plot(commnet,
     simgraph1,
     layout=graphlay,
     mark.expand = 20,
     vertex.size=5, size2=1, 
     vertex.label=NA)
```

The final visualization presents the intra-cluster edges. Note here than a majority of the eges exist in pairs. This doubling stems from the lack of directionality or weighting in the edges, resulting in roundtrip flights appearing twice, once for city A to city B and another for the reverse.

```{r}
plot(commnet,
     simgraph2,
     layout=graphlay,
     mark.expand = 20,
     vertex.size=5, size2=1, 
     vertex.label=NA)

```
